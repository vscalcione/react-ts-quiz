{"version":3,"file":"react-query.production.min.js","sources":["../src/core/utils.js","../src/core/config.js","../src/core/queryCache.js","../src/core/setFocusHandler.js","../src/react/ReactQueryCacheProvider.js","../src/react/ReactQueryConfigProvider.js","../src/react/utils.js","../src/react/useMutation.js","../src/react/useBaseQuery.js","../src/react/useInfiniteQuery.js","../src/react/useIsFetching.js","../src/react/usePaginatedQuery.js","../src/react/useQuery.js"],"sourcesContent":["export const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport function noop() {\n  return void 0\n}\nexport function identity(d) {\n  return d\n}\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    const { queryKey, queryFn, config } = args[0]\n    args = [queryKey, queryFn, config, ...args.slice(1)]\n  } else if (isObject(args[1])) {\n    const [queryKey, config, ...rest] = args\n    args = [queryKey, undefined, config, ...rest]\n  }\n\n  let [queryKey, queryFn, config = {}, ...rest] = args\n\n  queryFn = queryFn || config.queryFn\n\n  return [queryKey, queryFn ? { ...config, queryFn } : config, ...rest]\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport function getStatusBools(status) {\n  return {\n    isLoading: status === statusLoading,\n    isSuccess: status === statusSuccess,\n    isError: status === statusError,\n    isIdle: status === statusIdle,\n  }\n}\n","import { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const DEFAULT_CONFIG = {\n  shared: {\n    suspense: false,\n  },\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    queryFn: undefined,\n    initialStale: undefined,\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    onMutate: noop,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULT_CONFIG,\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    invalidQueryKey()\n  }\n\n  if (!Array.isArray(queryKey)) {\n    queryKey = [queryKey]\n  }\n\n  if (queryKey.some(d => typeof d === 'function')) {\n    invalidQueryKey()\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  if (!queryHash) {\n    invalidQueryKey()\n  }\n\n  return [queryHash, queryKey]\n}\n\nfunction invalidQueryKey() {\n  throw new Error('A valid query key is required!')\n}\n","import {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n  uid,\n  statusIdle,\n  Console,\n  isObject,\n  getStatusBools,\n} from './utils'\n\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCaches = [queryCache]\n\nconst actionInit = 'Init'\nconst actionFailed = 'Failed'\nconst actionMarkStale = 'MarkStale'\nconst actionMarkGC = 'MarkGC'\nconst actionFetch = 'Fetch'\nconst actionSuccess = 'Success'\nconst actionError = 'Error'\nconst actionSetState = 'SetState'\n\nexport function makeQueryCache({ frozen = isServer, defaultConfig } = {}) {\n  // A frozen cache does not add new queries to the cache\n  const globalListeners = []\n\n  const configRef = defaultConfig\n    ? { current: defaultConfig }\n    : defaultConfigRef\n\n  const queryCache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    queryCache.isFetching = Object.values(queryCache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    globalListeners.forEach(d => d(queryCache))\n  }\n\n  queryCache.subscribe = cb => {\n    globalListeners.push(cb)\n    return () => {\n      globalListeners.splice(globalListeners.indexOf(cb), 1)\n    }\n  }\n\n  queryCache.clear = ({ notify = true } = {}) => {\n    Object.values(queryCache.queries).forEach(query => query.clear())\n    queryCache.queries = {}\n    if (notify) {\n      notifyGlobalListeners()\n    }\n  }\n\n  queryCache.getQueries = (predicate, { exact } = {}) => {\n    if (predicate === true) {\n      return Object.values(queryCache.queries)\n    }\n\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = configRef.current.queries.queryKeySerializerFn(predicate)\n\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(queryCache.queries).filter(predicate)\n  }\n\n  queryCache.getQuery = queryKey =>\n    queryCache.getQueries(queryKey, { exact: true })[0]\n\n  queryCache.getQueryData = queryKey =>\n    queryCache.getQuery(queryKey)?.state.data\n\n  queryCache.removeQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.clear())\n  }\n\n  queryCache.cancelQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.cancel())\n  }\n\n  queryCache.invalidateQueries = async (\n    predicate,\n    { refetchActive = true, refetchInactive = false, exact, throwOnError } = {}\n  ) => {\n    try {\n      return await Promise.all(\n        queryCache.getQueries(predicate, { exact }).map(query => {\n          if (query.instances.length) {\n            if (\n              refetchActive &&\n              query.instances.some(instance => instance.config.enabled)\n            ) {\n              return query.fetch()\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch()\n            }\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.resetErrorBoundaries = () => {\n    queryCache.getQueries(true).forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  queryCache.buildQuery = (userQueryKey, config = {}) => {\n    config = {\n      ...configRef.current.shared,\n      ...configRef.current.queries,\n      ...config,\n    }\n\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = queryCache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { config })\n    } else {\n      query = makeQuery({\n        queryCache,\n        queryKey,\n        queryHash,\n        config,\n      })\n\n      if (config.infinite) {\n        if (\n          typeof query.state.canFetchMore === 'undefined' &&\n          typeof query.state.data !== 'undefined'\n        ) {\n          query.state.canFetchMore = config.getFetchMore(\n            query.state.data[query.state.data.length - 1],\n            query.state.data\n          )\n        }\n\n        // Here we seed the pageVariabes for the query\n        if (!query.pageVariables) {\n          query.pageVariables = [[...query.queryKey]]\n        }\n      }\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!frozen) {\n        queryCache.queries[queryHash] = query\n\n        if (isServer) {\n          notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    }\n\n    return query\n  }\n\n  queryCache.prefetchQuery = async (...args) => {\n    if (\n      isObject(args[1]) &&\n      (args[1].hasOwnProperty('throwOnError') ||\n        args[1].hasOwnProperty('force'))\n    ) {\n      args[3] = args[1]\n      args[1] = undefined\n      args[2] = undefined\n    }\n\n    let [queryKey, config, { force, throwOnError } = {}] = getQueryArgs(args)\n\n    try {\n      const query = queryCache.buildQuery(queryKey, config)\n      if (force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n      Console.error(err)\n    }\n  }\n\n  queryCache.setQueryData = (queryKey, updater, config = {}) => {\n    let query = queryCache.getQuery(queryKey)\n\n    if (!query) {\n      query = queryCache.buildQuery(queryKey, config)\n    }\n\n    query.setData(updater)\n  }\n\n  function makeQuery({ queryCache, queryKey, queryHash, config }) {\n    const initialData =\n      typeof config.initialData === 'function'\n        ? config.initialData()\n        : config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale =\n      !config.enabled ||\n      (typeof config.initialStale === 'function'\n        ? config.initialStale()\n        : config.initialStale ?? !hasInitialData)\n\n    const initialStatus = hasInitialData\n      ? statusSuccess\n      : config.enabled\n      ? statusLoading\n      : statusIdle\n\n    let query = {\n      queryKey,\n      queryHash,\n      config,\n      instances: [],\n      state: queryReducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n      }),\n    }\n\n    query.dispatch = action => {\n      query.state = queryReducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (isServer) return\n      clearTimeout(query.staleTimeout)\n\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          query.invalidate()\n        }\n      }, query.config.staleTime)\n    }\n\n    query.invalidate = () => {\n      clearTimeout(query.staleTimeout)\n      query.dispatch({ type: actionMarkStale })\n    }\n\n    query.scheduleGarbageCollection = () => {\n      if (!queryCache.queries[query.queryHash]) return\n      if (query.config.cacheTime === Infinity) {\n        return\n      }\n      query.dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          queryCache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.refetch = async () => {\n      try {\n        await query.fetch()\n      } catch (error) {\n        Console.error(error)\n      }\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.cancel = () => {\n      query.cancelled = cancelledError\n\n      if (query.cancelPromises) {\n        query.cancelPromises()\n      }\n\n      delete query.promise\n    }\n\n    query.clearIntervals = () => {\n      query.instances.forEach(instance => {\n        instance.clearInterval()\n      })\n    }\n\n    query.setState = updater =>\n      query.dispatch({ type: actionSetState, updater })\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      query.dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      query.scheduleStaleTimeout()\n    }\n\n    query.clear = () => {\n      clearTimeout(query.staleTimeout)\n      clearTimeout(query.cacheTimeout)\n      clearTimeout(query.retryTimeout)\n      query.clearIntervals()\n      query.cancel()\n      query.dispatch = noop\n      delete queryCache.queries[query.queryHash]\n    }\n\n    query.subscribe = (onStateUpdate = noop) => {\n      const instance = {\n        id: uid(),\n        onStateUpdate,\n      }\n\n      query.instances.push(instance)\n\n      query.heal()\n\n      instance.clearInterval = () => {\n        clearInterval(instance.refetchIntervalId)\n        delete instance.refetchIntervalId\n      }\n\n      instance.updateConfig = config => {\n        const oldConfig = instance.config\n\n        // Update the config\n        instance.config = config\n\n        if (!isServer) {\n          if (oldConfig?.refetchInterval === config.refetchInterval) {\n            return\n          }\n\n          query.clearIntervals()\n\n          const minInterval = Math.min(\n            ...query.instances.map(d => d.config.refetchInterval || Infinity)\n          )\n\n          if (\n            !instance.refetchIntervalId &&\n            minInterval > 0 &&\n            minInterval < Infinity\n          ) {\n            instance.refetchIntervalId = setInterval(() => {\n              if (\n                query.instances.some(instance => instance.config.enabled) &&\n                (isDocumentVisible() ||\n                  query.instances.some(\n                    instance => instance.config.refetchIntervalInBackground\n                  ))\n              ) {\n                query.fetch()\n              }\n            }, minInterval)\n          }\n        }\n      }\n\n      instance.run = async () => {\n        try {\n          // Perform the refetch for this query if necessary\n          if (\n            query.config.enabled && // Don't auto refetch if disabled\n            !query.wasSuspended && // Don't double refetch for suspense\n            query.state.isStale && // Only refetch if stale\n            (query.config.refetchOnMount || query.instances.length === 1)\n          ) {\n            await query.fetch()\n          }\n\n          query.wasSuspended = false\n        } catch (error) {\n          Console.error(error)\n        }\n      }\n\n      instance.unsubscribe = () => {\n        query.instances = query.instances.filter(d => d.id !== instance.id)\n\n        if (!query.instances.length) {\n          query.clearIntervals()\n          query.cancel()\n\n          if (!isServer) {\n            // Schedule garbage collection\n            query.scheduleGarbageCollection()\n          }\n        }\n      }\n\n      return instance\n    }\n\n    // Set up the core fetcher function\n    const tryFetchData = async (fn, ...args) => {\n      try {\n        // Perform the query\n        const promise = fn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelPromises = () => promise.cancel?.()\n\n        const data = await promise\n        delete query.shouldContinueRetryOnFocus\n\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        query.dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            query.retryTimeout = setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(fn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ fetchMore } = {}) => {\n      let queryFn = query.config.queryFn\n\n      if (!queryFn) {\n        return\n      }\n\n      if (query.config.infinite) {\n        const originalQueryFn = queryFn\n\n        queryFn = async () => {\n          const data = []\n          const pageVariables = [...query.pageVariables]\n          const rebuiltPageVariables = []\n\n          do {\n            const args = pageVariables.shift()\n\n            if (!data.length) {\n              // the first page query doesn't need to be rebuilt\n              data.push(await originalQueryFn(...args))\n              rebuiltPageVariables.push(args)\n            } else {\n              // get an up-to-date cursor based on the previous data set\n\n              const nextCursor = query.config.getFetchMore(\n                data[data.length - 1],\n                data\n              )\n\n              // break early if there's no next cursor\n              // otherwise we'll start from the beginning\n              // which will cause unwanted duplication\n              if (!nextCursor) {\n                break\n              }\n\n              const pageArgs = [\n                // remove the last argument (the previously saved cursor)\n                ...args.slice(0, -1),\n                nextCursor,\n              ]\n\n              data.push(await originalQueryFn(...pageArgs))\n              rebuiltPageVariables.push(pageArgs)\n            }\n          } while (pageVariables.length)\n\n          query.state.canFetchMore = query.config.getFetchMore(\n            data[data.length - 1],\n            data\n          )\n          query.pageVariables = rebuiltPageVariables\n\n          return data\n        }\n\n        if (fetchMore) {\n          queryFn = async (...args) => {\n            const { fetchMoreInfo, previous } = fetchMore\n            try {\n              query.setState(old => ({\n                ...old,\n                isFetchingMore: previous ? 'previous' : 'next',\n              }))\n\n              const newArgs = [...args, fetchMoreInfo]\n\n              query.pageVariables[previous ? 'unshift' : 'push'](newArgs)\n\n              const newData = await originalQueryFn(...newArgs)\n\n              const data = previous\n                ? [newData, ...query.state.data]\n                : [...query.state.data, newData]\n\n              query.state.canFetchMore = query.config.getFetchMore(\n                newData,\n                data\n              )\n\n              return data\n            } finally {\n              query.setState(old => ({\n                ...old,\n                isFetchingMore: false,\n              }))\n            }\n          }\n        }\n      }\n\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          const getCallbackInstances = () => {\n            const callbackInstances = [...query.instances]\n\n            if (query.wasSuspended) {\n              callbackInstances.unshift(query.fallbackInstance)\n            }\n            return callbackInstances\n          }\n\n          try {\n            // Set up the query refreshing state\n            query.dispatch({ type: actionFetch })\n\n            // Try to get the data\n            let data = await tryFetchData(queryFn, ...query.queryKey)\n\n            query.setData(old =>\n              query.config.isDataEqual(old, data) ? old : data\n            )\n\n            getCallbackInstances().forEach(\n              instance =>\n                instance.config.onSuccess &&\n                instance.config.onSuccess(query.state.data)\n            )\n\n            getCallbackInstances().forEach(\n              instance =>\n                instance.config.onSettled &&\n                instance.config.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            query.dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              getCallbackInstances().forEach(\n                instance =>\n                  instance.config.onError && instance.config.onError(error)\n              )\n\n              getCallbackInstances().forEach(\n                instance =>\n                  instance.config.onSettled &&\n                  instance.config.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    if (query.config.infinite) {\n      query.fetchMore = (\n        fetchMoreInfo = query.state.canFetchMore,\n        { previous = false } = {}\n      ) => query.fetch({ fetchMore: { fetchMoreInfo, previous } })\n    }\n\n    return query\n  }\n\n  return queryCache\n}\n\nexport function queryReducer(state, action) {\n  const newState = switchActions(state, action)\n\n  return Object.assign(newState, getStatusBools(newState.status))\n}\n\nfunction switchActions(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching: action.initialStatus === 'loading',\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status:\n          typeof state.data !== 'undefined' ? statusSuccess : statusLoading,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n          throwInErrorBoundary: true,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.instances.some(instance => instance.config.enabled)) {\n            return false\n          }\n\n          if (!query.state.isStale) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n          }\n\n          return query.config.refetchOnWindowFocus\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\nimport { queryCache, makeQueryCache } from '../core'\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear()\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\nimport { DEFAULT_CONFIG, defaultConfigRef } from '../core/config'\n\n//\n\nconst configContext = React.createContext()\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = useConfigContext()\n\n  const newConfig = React.useMemo(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValue\n\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULT_CONFIG) }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { useConfigContext } from './ReactQueryConfigProvider'\n\nimport {\n  uid,\n  isServer,\n  statusError,\n  statusSuccess,\n  getQueryArgs,\n} from '../core/utils'\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function useQueryArgs(args) {\n  const configContext = useConfigContext()\n\n  let [queryKey, config, ...rest] = getQueryArgs(args)\n\n  // Build the final config\n  config = {\n    ...configContext.shared,\n    ...configContext.queries,\n    ...config,\n  }\n\n  return [queryKey, config, ...rest]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (\n    queryInfo.query.config.suspense ||\n    queryInfo.query.config.useErrorBoundary\n  ) {\n    if (\n      queryInfo.query.state.status === statusError &&\n      queryInfo.query.state.throwInErrorBoundary\n    ) {\n      throw queryInfo.error\n    }\n\n    if (\n      queryInfo.query.config.suspense &&\n      queryInfo.status !== statusSuccess &&\n      queryInfo.query.config.enabled\n    ) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.query.fetch()\n    }\n  }\n}\n","import React from 'react'\n\n//\n\nimport { useConfigContext } from './ReactQueryConfigProvider'\nimport { useGetLatest, useMountedCallback } from './utils'\nimport {\n  statusIdle,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  Console,\n  uid,\n  noop,\n} from '../core/utils'\n\nconst getDefaultState = () => ({\n  status: statusIdle,\n  data: undefined,\n  error: null,\n})\n\nconst actionReset = {}\nconst actionLoading = {}\nconst actionResolve = {}\nconst actionReject = {}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState()\n  }\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading,\n    }\n  }\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data,\n    }\n  }\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error,\n    }\n  }\n  throw new Error()\n}\n\nexport function useMutation(mutationFn, config = {}) {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const getConfig = useGetLatest({\n    ...useConfigContext().shared,\n    ...useConfigContext().mutations,\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef()\n\n  const mutate = React.useCallback(\n    async (\n      variables,\n      { onSuccess = noop, onError = noop, onSettled = noop, throwOnError } = {}\n    ) => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue\n\n      try {\n        dispatch({ type: actionLoading })\n        snapshotValue = await config.onMutate(variables)\n\n        let data = await getMutationFn()(variables)\n\n        if (isLatest()) {\n          dispatch({ type: actionResolve, data })\n        }\n\n        await config.onSuccess(data, variables)\n        await onSuccess(data, variables)\n        await config.onSettled(data, null, variables)\n        await onSettled(data, null, variables)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await config.onError(error, variables, snapshotValue)\n        await onError(error, variables, snapshotValue)\n        await config.onSettled(undefined, error, variables, snapshotValue)\n        await onSettled(undefined, error, variables, snapshotValue)\n\n        if (isLatest()) {\n          dispatch({ type: actionReject, error })\n        }\n\n        if (throwOnError ?? config.throwOnError) {\n          throw error\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => dispatch({ type: actionReset }), [\n    dispatch,\n  ])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [\n    mutate,\n    {\n      ...state,\n      reset,\n      isIdle: state.status === statusIdle,\n      isLoading: state.status === statusLoading,\n      isSuccess: state.status === statusSuccess,\n      isError: state.status === statusError,\n    },\n  ]\n}\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useMountedCallback } from './utils'\n\nexport function useBaseQuery(queryKey, config = {}) {\n  // Make a rerender function\n  const rerender = useMountedCallback(React.useState()[1])\n\n  // Get the query cache\n  const queryCache = useQueryCache()\n\n  // Build the query for use\n  const query = queryCache.buildQuery(queryKey, config)\n\n  // Create a query instance ref\n  const instanceRef = React.useRef()\n\n  // Subscribe to the query when the subscribe function changes\n  React.useEffect(() => {\n    instanceRef.current = query.subscribe(() => rerender({}))\n\n    // Unsubscribe when things change\n    return instanceRef.current.unsubscribe\n  }, [query, rerender])\n\n  // Always update the config\n  React.useEffect(() => {\n    instanceRef.current.updateConfig(config)\n  })\n\n  // Run the instance when the query or enabled change\n  React.useEffect(() => {\n    if (config.enabled && query) {\n      // Just for change detection\n    }\n    instanceRef.current.run()\n  }, [config.enabled, query])\n\n  return {\n    ...query,\n    ...query.state,\n    query,\n  }\n}\n","//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { useQueryArgs, handleSuspense } from './utils'\n\nexport function useInfiniteQuery(...args) {\n  let [queryKey, config] = useQueryArgs(args)\n\n  config.infinite = true\n\n  const queryInfo = useBaseQuery(queryKey, config)\n\n  handleSuspense(queryInfo)\n\n  return queryInfo\n}\n","import React from 'react'\n\nimport { useMountedCallback } from './utils'\nimport { useQueryCache } from './ReactQueryCacheProvider'\n\nexport function useIsFetching() {\n  const queryCache = useQueryCache()\n  const [state, unsafeRerender] = React.useReducer(d => d + 1, 1)\n  const rerender = useMountedCallback(unsafeRerender)\n\n  React.useEffect(() => queryCache.subscribe(rerender), [queryCache, rerender])\n\n  return React.useMemo(() => state && queryCache.isFetching, [\n    queryCache.isFetching,\n    state,\n  ])\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { useQueryArgs, handleSuspense } from './utils'\nimport { getStatusBools } from '../core/utils'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\nexport function usePaginatedQuery(...args) {\n  let [queryKey, config = {}] = useQueryArgs(args)\n\n  // Keep track of the latest data result\n  const lastDataRef = React.useRef()\n\n  // If latestData is there, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  // Make the query as normal\n  const queryInfo = useBaseQuery(queryKey, config)\n\n  // If the query is disabled, get rid of the latest data\n  if (!queryInfo.query.config.enabled) {\n    lastDataRef.current = undefined\n  }\n\n  // Get the real data and status from the query\n  let { data: latestData, status } = queryInfo\n\n  // If the real query succeeds, and there is data in it,\n  // update the latest data\n  React.useEffect(() => {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  // Resolved data should be either the real data we're waiting on\n  // or the latest placeholder data\n  let resolvedData = latestData\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  // If we have any data at all from either, we\n  // need to make sure the status is success, even though\n  // the real query may still be loading\n  if (typeof resolvedData !== 'undefined') {\n    const overrides = { status: 'success', ...getStatusBools('success') }\n    Object.assign(queryInfo.query.state, overrides)\n    Object.assign(queryInfo, overrides)\n  }\n\n  const paginatedQueryInfo = {\n    ...queryInfo,\n    resolvedData,\n    latestData,\n  }\n\n  handleSuspense(paginatedQueryInfo)\n\n  return paginatedQueryInfo\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { useQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...useQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n"],"names":["_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","functionalUpdate","updater","old","stableStringifyReplacer","_","value","isObject","Object","assign","keys","sort","map","key","stableStringify","obj","JSON","stringify","a","Array","isArray","deepIncludes","b","some","isDocumentVisible","document","undefined","visibilityState","getQueryArgs","args","queryKey","queryFn","config","slice","rest","getStatusBools","status","isLoading","isSuccess","isError","isIdle","DEFAULT_CONFIG","shared","suspense","queries","queryKeySerializerFn","invalidQueryKey","d","queryHash","parse","initialStale","enabled","retry","retryDelay","attemptIndex","Math","min","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","refetchOnMount","isDataEqual","deepEqual","length","i","valueOf","prototype","hasOwnProperty","call","onError","onSuccess","onSettled","useErrorBoundary","mutations","throwOnError","onMutate","defaultConfigRef","current","Error","then","direct","Promise","resolve","body","recover","result","e","f","arguments","apply","this","reject","pact","state","s","o","_settle","bind","v","observer","_Pact","onFulfilled","onRejected","callback","_this","thenable","thrown","finalizer","queryCache","makeQueryCache","queryCaches","frozen","defaultConfig","globalListeners","configRef","isFetching","notifyGlobalListeners","values","reduce","acc","query","forEach","subscribe","cb","push","splice","indexOf","clear","notify","getQueries","predicate","exact","filter","getQuery","getQueryData","_queryCache$getQuery","data","removeQueries","cancelQueries","cancel","invalidateQueries","refetchActive","refetchInactive","all","instances","instance","fetch","invalidate","err","resetErrorBoundaries","throwInErrorBoundary","buildQuery","userQueryKey","initialData","hasInitialData","isStale","initialStatus","queryReducer","type","dispatch","action","onStateUpdate","scheduleStaleTimeout","clearTimeout","staleTimeout","Infinity","setTimeout","scheduleGarbageCollection","cacheTimeout","markedForGarbageCollection","refetch","heal","cancelled","cancelPromises","promise","clearIntervals","clearInterval","setState","setData","retryTimeout","id","refetchIntervalId","updateConfig","oldConfig","minInterval","setInterval","refetchIntervalInBackground","run","wasSuspended","unsubscribe","tryFetchData","fn","shouldContinueRetryOnFocus","failureCount","delay","fetchMore","infinite","originalQueryFn","pageVariables","rebuiltPageVariables","test","awaitBody","_isSettledPact","shouldContinue","_resumeAfterBody","_resumeAfterTest","shift","nextCursor","getFetchMore","pageArgs","canFetchMore","fetchMoreInfo","previous","isFetchingMore","newArgs","newData","_async","getCallbackInstances","callbackInstances","unshift","fallbackInstance","makeQuery","prefetchQuery","force","setQueryData","newState","updatedAt","Date","now","switchActions","removePreviousHandler","onWindowFocus","navigator","onLine","catch","setFocusHandler","handleFocus","_window","addEventListener","removeEventListener","queryCacheContext","React","createContext","useQueryCache","useContext","configContext","useConfigContext","useGetLatest","ref","useRef","useCallback","useQueryArgs","useMountedCallback","mounted","handleSuspense","queryInfo","_await","getDefaultState","actionReset","actionLoading","actionResolve","actionReject","mutationReducer","useBaseQuery","rerender","useState","instanceRef","useEffect","children","resolvedQueryCache","useMemo","Provider","configContextValue","newConfig","contextShared","contextQueries","contextMutations","c","useReducer","mutationFn","getMutationFn","getConfig","latestMutationRef","mutate","variables","mutationId","snapshotValue","isLatest","reset","lastDataRef","latestData","resolvedData","overrides","paginatedQueryInfo"],"mappings":"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"}